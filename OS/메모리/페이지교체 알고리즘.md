# 페이지 교체 알고리즘
## FIFO알고리즘

- 가장 오래전에 들어온 페이지가 희생자
- 이해하기 쉽고, 구현이 쉬운 방법
- 자주 사용되는 페이지가 교체될 가능성이 높음
    - 지역성에 대한 고려가 없음

## LRU 알고리즘

- 가장 오래전에 참조한 페이지가 희생자
- 시간적으로 거꾸로 찾는 최적 페이지 교체 알고리즘
- 지역성에 기반을 둔 교체 기법으로 가장 널리 사용됨
- 하드웨어 지원이 반드시 필요
    - 스택이나 카운터를 이용해야함

## LFU 알고리즘

- 사용횟수가 가장적은 페이지가 희생자
- 알고리즘 구현 비용이 비싸고 성능도 좋지 않아 사용x
- 문제점
    - 초기에만 많이 사용된 페이지는 교체되지 않음
    - 처음 교체되어 들어온 페이지는 바로 교체 될 수 있음

## NUR 알고리즘

### LRU보다 적은 overhead로 비슷한 성능 달성

### 참조 비트와 변형 비트가 존재

- 참조가 되지 않으면 0, 참조된적있으면 1
- 변형되지 않았으면 0, 변형된적 있으면 1
- 참조 비트는 주기적으로 0으로 초기화

### 교체 순서

- (R, M) = (0, 0)
- (R, M) = (0 ,1)
- (R, M) = (1 ,0)
- (R, M) = (1 ,1)

## Clock algorithm

- NUR 알고리즘을 실제적요한예
- 참조비트만 사용 → 주기적 초기화없음
- 페이지 프레임들을 순차적으로 가리키는 포인터 사용
- 포인터가 시계바늘처럼 돌면서 0인 페이지를 교체 대상으로 선정
- 먼저 적재된 페이지가 교체 될 가능성이 높음(FIFO 비슷)

## 2차기회(Second chance) algorithm

- clock 알고리즘에서 변형 비트를 함께 고려
- 검색시간이 길어짐
- 비트에 따른 교체 방법
    - (R, M) = (0, 0) - 교체페이지로 결정
    - (R, M) = (0, 1) - (0, 0) 변경, write-back list에 추가
    - (R, M) = (1, 0) - (0, 0) 변경후 포인터 이동
    - (R, M) = (1, 1) - (0, 1) 변경후 포인터 이동